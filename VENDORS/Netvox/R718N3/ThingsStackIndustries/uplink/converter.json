{
  "name": "converter",
  "type": "UPLINK",
  "debugMode": true,
  "configuration": {
    "scriptLang": "TBEL",
    "decoder": null,
    "tbelDecoder": "var data = decodeToJson(payload);\nvar deviceName = data.deviceInfo.deviceName;\nvar deviceType = data.deviceInfo.deviceProfileName;\nvar groupName = 'IAQ devices';\n// var customerName = 'Customer A';\n// use assetName and assetType instead of deviceName and deviceType\n// to automatically create assets instead of devices.\n// var assetName = 'Asset A';\n// var assetType = 'building';\n\n// If you want to parse incoming data somehow, you can add your code to this function.\n// input: bytes\n// expected output:\n//  {\n//    \"attributes\": {\"attributeKey\": \"attributeValue\"},\n//    \"telemetry\": {\"telemetryKey\": \"telemetryValue\"}\n//  }\n//\n// In the example - bytes will be saved as HEX string and also parsed as light level, battery level and PIR sensor value.\n//\n\nfunction decodePayload(input) {\n    var output = { attributes:{}, telemetry: {} };\n    // --- Decoding code --- //\n    var frmPayloadBytes = base64ToBytes(input.data);\n    var frmPayloadList = byteArrayToExecutionArrayList(frmPayloadBytes);\n    var fPort = input.get(\"fPort\");\n    if (fPort != null && frmPayloadList.length > 0) {\n        // output.telemetry.bytes = frmPayloadBytes;\n        // output.telemetry.bytesHex = bytesToHex(frmPayloadBytes);\n        switch (fPort) {\n            case 6:\n                reportDataCmd(frmPayloadList, output);\n                break;\n            case 7:\n\n                break;\n            case 10:\n\n                break;\n\n            case 20:\n\n                break;\n\n            default:\n                raiseError(\"Data decoding error. The 'f_port' = [\" + fPort + \"] \");\n        }\n    } else {\n        raiseError(\"Data decoding error. The 'f_port' field is missing\");\n    }\n    return output;\n}\n\n\nfunction reportDataCmd(frmPayload, output) {\n    var i = 0;\n    while (i < (frmPayload.length - 3)) {\n        var version = frmPayload[i++] & 0xff;\n        var deviceTypeId = frmPayload[i++] & 0xff;\n        var reportType = frmPayload[i++] & 0xff;\n        if (i < (frmPayload.length - 7) && version === 0x01 && deviceTypeId === 0x4A) {\n            switch (reportType) {\n                case 0:\n                    reportDataCmdPort6Type0(frmPayload.slice(i, i + 8), output);\n                    i +=8;\n                    break;\n                case 1:\n                    var len = 8;\n                    if (i < (frmPayload.length - 18) && (frmPayload[i + 8] & 0xff) ===  0x01\n                        && (frmPayload[i + 9] & 0xff) === 0x4A && (frmPayload[i + 10] & 0xff) === 2) {\n                        len = 19;\n                    }\n                    reportDataCmdPort6Type1_2(frmPayload.slice(i, i + len), output);\n                    i +=len;\n                    break;\n                case 3:\n                    reportDataCmdPort6Type3(frmPayload.slice(i, i + 8), output);\n                    i +=8;\n                    break;\n                case 4:\n                    reportDataCmdPort6Type4(frmPayload.slice(i, i + 8), output);\n                    i +=8;\n                    break;\n                default:\n\n            }\n        }\n    }\n}\n\nfunction reportDataCmdPort6Type0(data, output) {\n    var softwareVersion = parseBytesIntToFloat(data, 0, 1)/10;\n    var hardwareVersion = data[1];\n    var dateCodeStr = bytesToHex(data.slice(2, 4));\n    output.attributes.SWver = softwareVersion;\n    output.attributes.SWverSt = \"V\" + softwareVersion;\n    output.attributes.HWver = hardwareVersion;\n    output.attributes.Datecode = dateCodeStr;\n\n}\n\nfunction reportDataCmdPort6Type1_2(data, output) {\n    var current = reportDataCmdPort6CurrentVolt(data, output);\n    var multiplier1;\n    if (data.length === 8) {\n        multiplier1 = parseBytesToInt(data.slice(7));\n        output.telemetry.Current1 = current.current1 * multiplier1;\n        output.telemetry.Current2 = current.current2 * multiplier1;\n        output.telemetry.Current3 = current.current3 * multiplier1;\n        // output.telemetry.multiplier1 = multiplier1;\n    } else {\n        multiplier1 = parseBytesToInt(data.slice(7, 8));\n        var multiplier2 = parseBytesToInt(data.slice(12, 13));\n        var multiplier3 = parseBytesToInt(data.slice(13, 14));\n        output.telemetry.Current1 = current.current1 * multiplier1;\n        output.telemetry.Current2 = current.current2 * multiplier2;\n        output.telemetry.Current3 = current.current3 * multiplier3;\n        // output.telemetry.multiplier1 = multiplier1;\n        // output.telemetry.multiplier2 = multiplier2;\n        // output.telemetry.multiplier3 = multiplier3;\n    }\n}\n\nfunction reportDataCmdPort6Type3(data, output) {\n    var current = reportDataCmdPort6CurrentVolt(data, output);\n    var multiplier = multiplierByBit(data[7]);\n    multiplier.Current1 = current.current1;\n    multiplier.Current2 = current.current2;\n    multiplier.Current3 = current.current3;\n    // output.telemetry.multiplier = multiplier;\n    output.telemetry.Current1 = current.current1 * multiplier.multiplier1;\n    output.telemetry.Current2 = current.current2 * multiplier.multiplier2;\n    output.telemetry.Current3 = current.current3 * multiplier.multiplier3;\n    // output.telemetry.multiplier1 = multiplier.multiplier1;\n    // output.telemetry.multiplier2 = multiplier.multiplier2;\n    // output.telemetry.multiplier3 = multiplier.multiplier3;\n}\n\nfunction reportDataCmdPort6Type4(data, output) {\n    reportDataCmdPort6Volt(data[0], output);\n    var currentAlarm = parseByteToBinaryArray(data[1], 6, false);\n    // output.telemetry.dataAlarm = data[1];\n    // output.telemetry.Alarm = currentAlarm;\n    output.telemetry.LowCurrent1Alarm = currentAlarm[0];\n    output.telemetry.HighCurrent1Alarm = currentAlarm[1];\n    output.telemetry.LowCurrent2Alarm = currentAlarm[2];\n    output.telemetry.HighCurren2Alarm = currentAlarm[3];\n    output.telemetry.LowCurrent3Alarm = currentAlarm[4];\n    output.telemetry.HighCurrent3Alarm = currentAlarm[5];\n}\n\nfunction reportDataCmdPort6CurrentVolt(data, output) {\n    reportDataCmdPort6Volt(data[0], output);\n    var current = {};\n    current.current1 = parseBytesToInt(data.slice(1, 3));\n    current.current2 = parseBytesToInt(data.slice(3, 5));\n    current.current3 = parseBytesToInt(data.slice(5, 7));\n    return current;\n}\n\nfunction reportDataCmdPort6Volt(data, output) {\n    var volt = parseByteToBinaryArray(data);\n    var voltValue =  parseBinaryArrayToInt(volt, 1) * 0.1;\n    output.telemetry.Volt = voltValue;\n    if (volt[7] === 1) {\n        output.telemetry.LowVolt = true;\n    }\n}\n\nfunction multiplierByBit(data) {\n    var multiplier = {};\n    var binaryArray = parseByteToBinaryArray(data);\n    multiplier.multiplier1 = multiplierByBitValue(parseBinaryArrayToInt(binaryArray, 6, 2));\n    multiplier.multiplier2 = multiplierByBitValue(parseBinaryArrayToInt(binaryArray, 4, 2));\n    multiplier.multiplier3 = multiplierByBitValue(parseBinaryArrayToInt(binaryArray, 2, 2));\n    return multiplier;\n}\n\nfunction multiplierByBitValue(index) {\n    var results = [1, 5, 10, 100];\n    return results[index];\n}\n\n// --- attributes and telemetry objects ---\nvar telemetry = {};\nvar attributes = {};\n// --- attributes and telemetry objects ---\n\n// --- Timestamp parsing\nvar dateString = data.time;\nvar timestamp = -1;\nif (dateString != null) {\n    timestamp = new Date(dateString).getTime();\n    if (timestamp == -1) {\n        var secondsSeparatorIndex = dateString.lastIndexOf('.') + 1;\n        var millisecondsEndIndex = dateString.lastIndexOf('+');\n        if (millisecondsEndIndex == -1) {\n            millisecondsEndIndex = dateString.lastIndexOf('Z');\n        }\n        if (millisecondsEndIndex == -1) {\n            millisecondsEndIndex = dateString.lastIndexOf('-');\n        }\n        if (millisecondsEndIndex == -1) {\n            if (dateString.length >= secondsSeparatorIndex + 3) {\n                dateString = dateString.substring(0, secondsSeparatorIndex + 3);\n            }\n        } else {\n            dateString = dateString.substring(0, secondsSeparatorIndex + 3) +\n                dateString.substring(millisecondsEndIndex, dateString.length);\n        }\n        timestamp = new Date(dateString).getTime();\n    }\n}\n// If we cannot parse timestamp - we will use the current timestamp\nif (timestamp == -1) {\n    timestamp = Date.now();\n}\n// --- Timestamp parsing\n\n// You can add some keys manually to attributes or telemetry\nattributes.deduplicationId = data.deduplicationId;\n\n// You can exclude some keys from the result\nvar excludeFromAttributesList = [\"deviceName\", \"rxInfo\", \"confirmed\", \"data\", \"deduplicationId\",\"time\", \"adr\", \"dr\", \"fCnt\"];\nvar excludeFromTelemetryList = [\"data\", \"deviceInfo\", \"txInfo\", \"devAddr\", \"adr\", \"time\", \"fPort\", \"region_common_name\", \"region_config_id\", \"deduplicationId\"];\n\n// Message parsing\n// To avoid paths in the decoded objects we passing false value to function as \"pathInKey\" argument.\n// Warning: pathInKey can cause already found fields to be overwritten with the last value found.\n\nvar telemetryData = toFlatMap(data, excludeFromTelemetryList, false);\nvar attributesData = toFlatMap(data, excludeFromAttributesList, false);\n\nvar uplinkDataList = [];\n\n// Passing incoming bytes to decodePayload function, to get custom decoding\nvar customDecoding = decodePayload(data);\n\n// Collecting data to result\nif (customDecoding.?telemetry.size() > 0) {\n    telemetry.putAll(customDecoding.telemetry);\n}\n\nif (customDecoding.?attributes.size() > 0) {\n    attributes.putAll(customDecoding.attributes);\n}\n\ntelemetry.putAll(telemetryData);\nattributes.putAll(attributesData);\n\nvar result = {\n    deviceName: deviceName,\n    deviceType: deviceType,\n//  assetName: assetName,\n//  assetType: assetType,\n//  customerName: customerName,\n    groupName: groupName,\n    attributes: attributes,\n    telemetry: {\n        ts: timestamp,\n        values: telemetry\n    }\n};\n\nreturn result;",
    "encoder": null,
    "tbelEncoder": null,
    "updateOnlyKeys": [
      "tenantId",
      "tenantName",
      "applicationId",
      "applicationName",
      "deviceProfileId",
      "deviceProfileName",
      "devEui",
      "devAddr",
      "fPort",
      "frequency",
      "bandwidth",
      "spreadingFactor",
      "codeRate",
      "battery",
      "pir",
      "daylight",
      "confirmed",
      "gatewayId",
      "channel",
      "rfChain",
      "crcStatus"
    ]
  },
  "additionalInfo": {
    "description": ""
  },
  "edgeTemplate": false
}