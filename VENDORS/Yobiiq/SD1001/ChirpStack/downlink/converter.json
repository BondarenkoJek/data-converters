{
    "name": "Downlink data converter for Yobiiq SD-1001",
    "type": "DOWNLINK",
    "debugMode": true,
    "configuration": {
      "scriptLang": "JS",
      "decoder": null,
      "tbelDecoder": null,
      "encoder": "// Encode downlink data from incoming Rule Engine message\n\n// msg - JSON message payload downlink message json\n// msgType - type of message, for ex. 'ATTRIBUTES_UPDATED', 'POST_TELEMETRY_REQUEST', etc.\n// metadata - list of key-value pairs with additional data about the message\n// integrationMetadata - list of key-value pairs with additional data defined in Integration executing this converter\n\n/** Encoder **/\n\n\n// Process data from incoming message and metadata\nvar input = {\n    fPort : parseInt(metadata.rc_fPort),\n    data : msg,\n    variables: null,\n    devEui : metadata.cs_devEui,\n    applicationId: metadata.cs_applicationId,\n};\n\n// Result object with encoded downlink payload\nvar result = {\n\n    // downlink data content type: JSON, TEXT or BINARY (base64 format)\n    contentType: \"TEXT\",\n\n    // downlink data\n    data: bytesToBase64(encodeDownlink(input).bytes),\n\n    // Optional metadata object presented in key/value format\n    metadata: {\n            DevEUI: input.devEui,\n            fPort: input.fPort,\n    }\n\n};\n\n\nreturn result;\n\nfunction bytesToBase64(bytes) {\n  var binary = '';\n  for (var i = 0; i < bytes.length; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return btoa(binary);\n}\n\n\n/************************************************************************************************************/\n\n// Encode encodes the given object into an array of bytes. (ChirpStack v3)\n//  - fPort contains the LoRaWAN fPort number\n//  - obj is an object, e.g. {\"temperature\": 22.5}\n//  - variables contains the device variables e.g. {\"calibration\": \"3.5\"} (both the key / value are of type string)\n// The function must return an array of bytes, e.g. [225, 230, 255, 0]\nfunction Encode(fPort, obj, variables) {\n    // Constants for downlink\n    var CONFIG_DOWNLINK = {\n        TYPE    : \"Type\",\n        CONFIG  : \"Config\"\n    };\n\n    try\n    {\n        if(obj[CONFIG_DOWNLINK.TYPE] == CONFIG_DOWNLINK.CONFIG)\n        {\n            return encodeDeviceConfiguration(obj[CONFIG_DOWNLINK.CONFIG], variables);\n        }\n    }catch(error)\n    {\n\n    }\n    return [];\n}\n\n// Encode downlink function. (ChirpStack v4 , TTN)\n//\n// Input is an object with the following fields:\n// - data = Object representing the payload that must be encoded.\n// - variables = Object containing the configured device variables.\n//\n// Output must be an object with the following fields:\n// - bytes = Byte array containing the downlink payload.\nfunction encodeDownlink(input) {\n    return {\n        bytes: Encode(null, input.data, input.variables)\n    };\n}\n\n\n/************************************************************************************************************/\n\n\nfunction encodeDeviceConfiguration(objArray, variables)\n{\n    // Constants for device configuration \n    var CONFIG_DEVICE = {\n        PORT : 50,\n        CHANNEL : parseInt(\"0xFF\", 16),\n        TYPES : {\n            \"reportingInterval\" : {TYPE : parseInt(\"0x03\", 16), SIZE : 2, MIN : 1, MAX : 65535,},\n            \"smokeDetector\" : {TYPE : parseInt(\"0x00\", 16), SIZE : 1, MIN : 0, MAX : 1,},\n            \"silenceBuzzer\" : {TYPE : parseInt(\"0x0A\", 16), SIZE : 2, MIN : 0, MAX : 65535,},\n            \"confirmedUplink\" : {TYPE : parseInt(\"0x01\", 16), SIZE : 1, MIN : 0, MAX : 1,},\n        }\n    };\n    var encoded = [];\n    var index = 0;\n    var field = [\"Param\", \"Value\"];\n    try\n    {\n        for(var i=0; i<objArray.length; i=i+1)\n        {\n            var obj = objArray[i];\n            var config = CONFIG_DEVICE.TYPES[obj[field[0]]];\n            var value = obj[field[1]];\n            if(obj[field[1]] >= config.MIN && obj[field[1]] <= config.MAX)\n            {\n                encoded[index] = CONFIG_DEVICE.CHANNEL;\n                index = index + 1;\n                encoded[index] = config.TYPE;\n                index = index + 1;\n                if(config.SIZE == 1)\n                {\n                    encoded[index] = value;\n                    index = index + 1;\n                }else if(config.SIZE == 2)\n                {\n                    switch(config.TYPE)\n                    {\n                        case 3: // reporting interval\n                            var lowByte = value % 256;\n                            encoded[index] = ((lowByte & parseInt(\"0x0F\", 16)) << 4) +  (lowByte >> 4);\n                            index = index + 1;\n                            encoded[index] = (value >> 8) % 256;\n                            index = index + 1;\n                            break;\n                        default:\n                            encoded[index] = (value >> 8) % 256;\n                            index = index + 1;\n                            encoded[index] = value % 256;\n                            index = index + 1;\n                            break;\n                    }\n                }\n            }else\n            {\n                // Error\n                return [];\n            }\n        }\n    }catch(error)\n    {\n        // Error\n        return [];\n    }\n    return encoded;\n}",
      "tbelEncoder": "// Encode downlink data from incoming Rule Engine message\n\n// msg - JSON message payload downlink message json\n// msgType - type of message, for ex. 'ATTRIBUTES_UPDATED', 'POST_TELEMETRY_REQUEST', etc.\n// metadata - list of key-value pairs with additional data about the message\n// integrationMetadata - list of key-value pairs with additional data defined in Integration executing this converter\n\n/** Encoder **/\n\n\n// Process data from incoming message and metadata\nvar input = {\n    fPort : parseInt(metadata.rc_fPort),\n    data : msg,\n    variables: null,\n    devEui : metadata.cs_devEui,\n    applicationId: metadata.cs_applicationId,\n};\nvar bytes = encodeDownlink(input).bytes;\n// Result object with encoded downlink payload\nvar result = {\n\n    // downlink data content type: JSON, TEXT or BINARY (base64 format)\n    contentType: \"TEXT\",\n\n    // downlink data\n    data: btoa(bytesToHex(bytes)),\n\n    // Optional metadata object presented in key/value format\n    metadata: {\n            DevEUI: \"401e471381e910ad\",//input.devEui,\n            fPort: input.fPort,\n    }\n\n};\n\nfunction getDigitStringArrayEvenFormat(bytes, index, size)\n{\n  var hexString = [];\n  for(var i=0; i<size; i=i+1)\n  {\n    hexString.push(bytes[index+i].toString(16));\n  }\n  return hexString.map(toEvenHEX);\n}\n\nfunction toEvenHEX(hex)\n{\n  if(hex.length == 1)\n  {\n    return \"0\"+hex;\n  }\n  return hex;\n}\n\n\n/************************************************************************************************************/\n\n// Encode encodes the given object into an array of bytes. (ChirpStack v3)\n//  - fPort contains the LoRaWAN fPort number\n//  - obj is an object, e.g. {\"temperature\": 22.5}\n//  - variables contains the device variables e.g. {\"calibration\": \"3.5\"} (both the key / value are of type string)\n// The function must return an array of bytes, e.g. [225, 230, 255, 0]\nfunction Encode(fPort, obj, variables) {\n    // Constants for downlink\n    var CONFIG_DOWNLINK = {\n        TYPE    : \"Type\",\n        CONFIG  : \"Config\"\n    };\n\n    try\n    {\n        if(obj[CONFIG_DOWNLINK.TYPE] == CONFIG_DOWNLINK.CONFIG)\n        {\n            return encodeDeviceConfiguration(obj[CONFIG_DOWNLINK.CONFIG], variables);\n        }\n    }catch(error)\n    {\n    return [error.message];\n    }\n    return [];\n}\n\n// Encode downlink function. (ChirpStack v4 , TTN)\n//\n// Input is an object with the following fields:\n// - data = Object representing the payload that must be encoded.\n// - variables = Object containing the configured device variables.\n//\n// Output must be an object with the following fields:\n// - bytes = Byte array containing the downlink payload.\nfunction encodeDownlink(input) {\n    return {\n        bytes: Encode(null, input.data, input.variables)\n    };\n}\n\n/************************************************************************************************************/\n\nfunction encodeDeviceConfiguration(obj, variables)\n{\n    // Constants for device configuration \n    var CONFIG_DEVICE = {\n        PORT : 50,\n        CHANNEL : parseInt(\"0xFF\", 16),\n        TYPES : {\n            \"ReportingInterval\" : {TYPE : parseInt(\"0x03\", 16), SIZE : 2, MIN : 1, MAX : 65535,},\n            \"SmokeDetector\" : {TYPE : parseInt(\"0x00\", 16), SIZE : 1, MIN : 0, MAX : 1,},\n            \"SilenceBuzzer\" : {TYPE : parseInt(\"0x0A\", 16), SIZE : 2, MIN : 0, MAX : 65535,},\n            \"ConfirmedUplink\" : {TYPE : parseInt(\"0x01\", 16), SIZE : 1, MIN : 0, MAX : 1,},\n        }\n    };\n\n    var encoded = [];\n    var index = 0;\n    var field = [\"Param\", \"Value\"];\n    try\n    {\n        var config = CONFIG_DEVICE.TYPES[obj[field[0]]];\n        var value = obj[field[1]];\n        if(obj[field[1]] >= config.MIN && obj[field[1]] <= config.MAX)\n        {\n            encoded[index] = CONFIG_DEVICE.CHANNEL;\n            index = index + 1;\n            encoded[index] = config.TYPE;\n            index = index + 1;\n            if(config.SIZE == 1)\n            {\n                encoded[index] = value;\n                index = index + 1;\n            }else if(config.SIZE == 2)\n            {\n                switch(config.TYPE)\n                {\n                    case 3: // reporting interval\n                        var lowByte = value % 256;\n                        encoded[index] = ((lowByte & parseInt(\"0x0F\", 16)) << 4) +  (lowByte >> 4);\n                        index = index + 1;\n                        encoded[index] = (value >> 8) % 256;\n                        index = index + 1;\n                        break;\n                    default:\n                        encoded[index] = (value >> 8) % 256;\n                        index = index + 1;\n                        encoded[index] = value % 256;\n                        index = index + 1;\n                        break;\n                }\n            }\n        }else\n        {\n            // Error\n            return [];\n        }\n    }catch(error)\n    {\n        // Error\n        return [];\n    }\n    return encoded;\n}\n\n\n\n\n\n\n\nreturn result;",
      "updateOnlyKeys": [
        "tenantId",
        "tenantName",
        "applicationId",
        "applicationName",
        "deviceProfileId",
        "deviceProfileName",
        "devEui",
        "devAddr",
        "fPort",
        "frequency",
        "bandwidth",
        "spreadingFactor",
        "codeRate",
        "battery",
        "pir",
        "daylight",
        "confirmed",
        "gatewayId",
        "channel",
        "rfChain",
        "crcStatus"
      ]
    },
    "additionalInfo": {
      "description": ""
    },
    "edgeTemplate": false
  }